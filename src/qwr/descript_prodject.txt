Фаылы проекта распределены по нескольким каталогам с разными правами доступа
внешних пользователей. В каждам каталоге могут лежать файла от разных проектов.
Имя проета (идентификатор) соответствует имени файла, а тип файла определяет его
назначение. Локальный набор файлов проекта аналогичен внешним и процедура загрузки
данных идентична. Сохранение информации идет только в локальный набор файлв.--------

Описание работы программы и распределение функциональности
1) создается первый пользователь по имени компьютера
2) если есть в ком-строке пользователь, то он создается вторым.
Со временем он примеет значения от пользователя подгруженног из справочника
пока пользователь не синхронизировани со справочником он не может бвть назначен.
3)создается файл инициализации первым из списка. Он может быть откорректирован
на основе данных из командной строки.
4)на основе подгрузки файла инициализации создаются файлы конфигурации.
данные читаются из них. если файлов конфигурации нет, то вторым в списке
файлов создается файл конфигурации по умолчанию.
Это означает, что в начале создается пустой объект, а потом заполняется данными.
Распределение базового элемента ===============================================
----------------------------------------------------------------+-------------+
  тип  !  имя  !№! базовое назнач.!по умолчанию! справ. внешних !создание элем!
-------+-------+-+----------------+------------+----------------+-------------+
int    ! chang !1! время изменения!  0         ! время изменения! для логики  !
String ! titul !2! наименование   !  задается  ! путь и имя     ! обязательно !
String ! descr !3! описание       !  null      ! часовой пояс   !анализируется!
short  ! typ   !4! источник       !  задается  ! на что показыв ! выбор логики!
boolean! isusr !5! используется   !  false     ! синхронизация  ! для логики  !
boolean! solvd !6! разрешено      !  true      ! доступ чтения  ! для логики  !
int    ! owner !7! владелец       !  0         ! владелец       !информационны!
int    ! key   !8! время создания !генерируется! время создания !основной ключ!
-------+-------+-+----------------+------------+----------------+-------------+

Интерпретация заголовков файлов проекта
--------------------------------------------------------------------------------------
 тип ! имя !def-t! инициализация  !  конфигурация  ! спр. локальных ! справ. внешних !
-----+-----+-----+----------------+----------------+----------------+----------------+
int   chang  0   ! время изменения! время изменения! время изменения! время изменения!
Str.  titul зад. ! путь и имя     ! путь и имя     ! путь и имя     ! путь и имя     !
Str.  descr null ! описание       ! описание       ! описание       ! часовой пояс   !
short typ    0   ! -0-            ! -1.....        ! тип элемента   ! на что показыв !
bool. isusr false!                ! факт доступност!проишошла замена! синхронизация  !
bool. solv  true !                ! разрешение     ! нужно сохранить! доступ чтения  !
int   owner  0   !                ! ИД создателя   ! ИД конфигурации! ИД создателя   !
int   key   время! время создания ! время создания ! время создания ! время создания !
-----+-----+-----+----------------+----------------+----------------+----------------+
short sourc = 0-создание 1-инициализация, 2-конфигурация, 3-локальный критерий,
4-локальный справочник, 5-внешний критерий,6-внешний справочник,7-глобальный критерий

Распределение элементов справочника файлов
--------------------------------------------------------------------------------------
 тип ! имя !def-t! справоч. путей ! справ.элементов!  пользователь  ! справоч.файлов !
-----+-----+-----+----------------+----------------+----------------+----------------+
int   chang  0   ! время изменения! время изменения! время изменения! время изменения!
Str.  titul зад. ! путь           ! именование     ! имя            ! путь           !
Str.  descr null ! часовой пояс   ! описание       ! полное имя     ! час(наследует) !
short typ    0   ! куда показывает! источник       ! источник       ! куда (наследует)
bool. isusr false! доступность пут! применяется    ! применяется    ! доступность пут!
bool. solv  true ! разрешение     ! разрешено испол! разрешено испол! разрешение(насл)     !
int   owner  0   ! ИД создателя   ! ИД создателя   ! ИД создателя   ! ключ пути(наслд)      !
int   key   время! время создания ! время создания ! время создания ! время создания !
-----+-----+-----+----------------+----------------+----------------+----------------+

Заначения  typ для EiFile и EiPath
0 - инициализация элемента до присвоения значений в том числе из командной строки
1 - файлы и папки локальной базы
2 - файлы и папки внешних данных не синхронизуемых (данные берутся но не проверяются)
3 - файлы и папки внешних данных подлежащих синхронизации изменения данных
При добавлении в справочник файлов они наследуют параменты от папки.
При добавлении файлов из сомандной строки наследование идет от lpPath.get(0),
соответствующее текущей папки.
!!! параметры файла в <EiFile> lsFile прописываются из TITUL читаемого файла !!!
=====================================================================================


 * Процедуру удаления может запустить только администратор.
 * Изменение элемента может произвести только администратор,
 * если данный элемент не задействован во внешних проектах.
 * При подключении нового проекта проверяется соответствие элементов,
 * если обнаружено несоответствие проект не синхронизируется (флаг сброшен).
 * В момент создания элемента проверяется существование одноименного
 * элемента во внешних справочниках с которыми установлена синхронизация


 * Класс описывающий пользователей проектов
 * имеет логин, полное имя, дату создания и кто создал,
 * дату последней регистрации, флаг далее не использовать,
 * флаг использования в проектах, уровень пользователя:
 * (3) администратор текущего проекта, (2) администратор из внешних
 * проектов, (1) пользователь внешних проектов, (0) пользователь проекта,
 * (-1) новый пользователь,(-2) новый пользователь из внешних проектов.
 * (-3) инициализация нового пользователя
 * Администратор может создавать пользователей проекта,
 * редактировать внешние пути, запускать процедуру удаления
 * объекта, но не может пополнять списки в отличии от
 * пользователя в данном проекте что бы сократить регистрации
 * под администратором ( в байте уровня может храниться пароль)
 * Флаг не использовать может быть установлен,если логин не встречается
 * в записях проекта(переопределен) после чего его наследуют
 * внешние проекты. Если логин не используется во внешних проектах,
 * то сбрасывается флаг используется в проектах и объект может быть удален.
 * Администратор может на себя забрать объекты созданные
 * пользователем проекта (перопределить) при неизменной дате создания.
 * Пользователь создается администратором или активируется из
 * внешнего пользователя с определением флага "админ" (см. ElGuid)
//====================================================================================
Описание старта программы
1) Проходит инициализация всех констант - class BgFile static block initialization 63
    lengthSuffix;//длина суфикса определяющего тип файла
    glob="*{xxx";//маска фильтрации типов файлов в каталоге
2) Создаются первые записи в справочниках - class InGuid static block initialization
    lsUser.add = имя компьютера хххххххх
    mpUser.putIfAbsent= имя компьютера с неопределенным ключем
    lpPath.add = путь по умолчанию
    lsFile.add = путь к файлу инициализации по умолчению ????????
3) Чтение компьютерных установок - class BgFile defineComputerUserSeting 92
4) Анализ командной строки - class BgFile parsingComandString 356
 Файл инициализации имеет просую структуру из строк с именеми файлов конфигурации.
 Файл инициализации берется из командной стоки или по предопределенному имени.
 Определяется при старте программы и в дальнейшем больше не изменяется.
 Имя файла инициализации хранится в переменной FileType.ini.patc
 Если на основании анализа командной строки не удается определить файл инициализации,
 то он создается на основе переменной FileType.ini.defNameFile.
 Аналогично происходят действия с файлом конфигурации.
 Если при анализе командной строки имя пользователя не определено, то значение
 переменной (String) BgFile.userPrj остается равное null.
 Если в командной строке найдено имя пользователя, то оно записывается в
FileGroupRecords.USERI.create(new EiUser(y)); >> mpUser.put((long)o.getKey(),o);



Описание работы программы и распределение функциональности
1) создается первый пользователь по имени компьютера
2) если есть в ком-строке пользователь, то он создается вторым.
Со временем он примеет значения от пользователя подгруженног из справочника
пока пользователь не синхронизировани со справочником он не может бвть назначен.
3)создается файл инициализации первым из списка. Он может быть откорректирован
на основе данных из командной строки.
4)на основе подгрузки файла инициализации создаются файлы конфигурации.
данные читаются из них. если файлов конфигурации нет, то вторым в списке
файлов создается файл конфигурации по умолчанию.

======================================================================================
Режимы графического окна: флаг изменения старта, флаг изменения дительности, флаг
определения предшественников, флаг определения последователей, флаг определения группы
связей. длительность меняется движеним мыши с удержанием кнопки вверх - больше и вниз-
меньше. Движение с удержанием кнопки влево-вправо изменяет точку старта. Одиночный
щелчек выбирает работу. Если перед работой то задается режим предшественников, если
перед работой - то режим последователей. Следующий одиночный щелчек определяет парную
работу и завершает установку связи. Двойной щелчек активизирует режим множественных
связей. Последующие одиночный щелчки определяют парную работу. На последней парной
работе двойной щелчек отключает режим множественных связей. Флаги динамического
экрана - по вертикали и по горизонтали задают режим при котором базовая работа
находится по середине экрана. Флан автматического масштабирования задает режим при
котором она вписывается по продолжительности в пределы экрана так, что бы занимать
не более половины ширины экрана. По краям экрана находятся полосы на которых
отражается место положения работ (слева или справа) оказавшимися за пределами экрана
- что то виде логарифмической шкалы. Полосы показываются в режиме автомасштабирования.
//===================================================================================
!!! изменять элемент может только владелец с обязательным квитированием остальных
*************************************************************************************
Пусть количество баз синхронизации ограничено числом Long 64/4=16 или 32/4=8
тогда значение 0 в тетраде означает что данная база еще не прочитана,
а 15 что данную базу не сканируем. Тогда таблица может выглядеть следующим образом
ввожу режим модификации, режим захвата поля для модификации
Если элемент не используется во внешней базе то и ни как не отрабатывается

! было!увидел!стало! Возможные процессы и шаги пизменения sourc в локальной базе:
+-----+------+-----+----------------------------------------------------------------+
!  =  ! блок !  15 ! L элемент исключен из сканирования
!  =  ! старт!  0  ! L элемент подготовлен к началу сканирования
+-----+------+-----+----------------------------------------------------------------+
!  =  ! иниц !  1  ! L создан на основе базовых спрвавочников (не изменяема)
!  =  ! чтен !  2  ! L создан из подкачки ненормированного документа
!  =  ! ввод !  3  ! L создан или откорректирована из подкачки для внешенй регистрации
+-----+------+-----+----------------------------------------------------------------+
!  2  !корркт!  3  ! L введена или откорректирована из подкачки для внешенй регистрации
!  4  !просм !  3+ ! L НЕ используется определенная локально
!  3  !просм !  4  ! L локальный используется
!  3  !блокир!  5  ! L локальный используется ЗАБЛОКИРОВАН для изменения
!  5  !снятьБ!  3+ ! L локальный используется Болокировка снята
!  6  !  13  !  4+ ! L локальный используется изменение прошло по кругу
!  5  !измен !  6  ! L локальный используется изменен
!  5  ! 3,4  !  11 ! L локальный используется изменен передан
+-----+------+-----+----------------------------------------------------------------+
!  3  !запрет!  7  ! L запрещено и НЕ используется
!  7  !снятьЗ!  3+ ! L Снять запрещено и НЕ используется
!  7  ! удал !  8  ! L старт сканирования на возможность удаления
!  8  ! 11,12!  8  ! L завершение сканирования отрицательное
!  8  !  10  !  =  ! L удаление  (сканирование)
+-----+------+-----+----------------------------------------------------------------+
!  =  !  3,4 !  10 ! P получена из внешних справочников НЕ используется здесь удален
!  10 !  3,4 !  11 ! P используется в проекте внешнего определения здесь
!  11 !  3,4 !  10+! P получена из внешних справочников НЕ используется (окончание)
!  11 !  5   !  12 ! P внешний используется заблокирован
!  12 !  4   !  11+! P внешний используется заблокирован (окончание)
!  11 !  6   !  13 ! P внешний используется модифицирован по внешнему
!  12 !  6   !  13 ! P внешний используется модифицирован по внешнему
!  13 !  4   !  11+! P внешний используется модифицирован по внешнему (окончание)
!  13 !  10  !  3+ ! P модифицирован принят НЕ используется
!  13 !  13  !  4+ ! P модифицирован принят используется
+-----+------+-----+----------------------------------------------------------------+
!  11 !  7   !  14 ! P запрещено,но используется внешнего определения
!  14 !  3   !  11 ! P запрещено СНЯТО ,но используется внешнего определения
!  10 !отсутв!  =  ! P запрещено,НЕ используется внешнего определения, удаление
+-----+------+-----+----------------------------------------------------------------+
Работа выполняется за два прохода. На первом берутся данные из внешних источников и
заносятся в соответствующие тетрады (младшая тетрада - локальные данные). На втором
проходе выполняется анализ собранных данных. Независимый проход контролирует
использование элемента в локальной базе. Переменная названа STATUS
Сокращения: блок-исключить данный путь из анализа; старт-команда на сканирования по
данному элементу всех путей идет после изменения статуса локальных данных или по
времени; иниц- в процесе инициализации; чтен- в процесе чтения локальных данных;
ввод - результат ручного ввода данных; корркт - результат ручной корректировки;
просм- результат сканирования локальных данных на предмет использования элемента;
блокир, снятьБ - блокировка и разблокировка для информировании о возможном изменении
данных; измен - факт изменения данных в любом из полей; запрет, снятьЗ - запрещение
назначения данного элемента, его применения; удал - команда на удаление элемента;
отсутв - данный элемент в базе хозяина не найден, отсутствуют коды для данного
элемента 3,4,5,6,7,8 во внешних источниках и активизирует процесс удаления элемента
из локальной базы.


*--*--abstract class GeneralElement //элемент справочника
!  !  String    title;      //1)наименование элемента
!  !  String    union;      //2)объединение
!  !  String    descript;   //3)описание элемента
!  !  long      status;     //4) состояние элемента
!  !  int       order;      //5)порядок следования
!  !
!  +*--abstract class   XXXXXXX extends GeneralElement
!   !   int       key;    //8) время создания в секундах с 1 января 1970г.(ключ)
!   !   int       owner;  //7) идентификатор пользователя создавшего элемент
!   !   int       chang;  //6) время последней регистрации (* int)
!   V
V
+*--class EjAuthor extends GeneralElement implements InterfaceElement
 !
 !  *--abstract class AlternativeElement implements InterfaceElement
 !  !    String    title;  //наименование элемента
 !  !    String    alias;  //альтернативное название
 V  V
public interface InterfaceElement
-------------------------------------------------------------------------------------
abstract class PrimitivElement<TYP> {
    protected TYP       keyEl;  //8) время создания в секундах с 1 января 1970г.(ключ)
    protected TYP       keyBl;  //ссылка на базовый элемент
    protected String    titul;  //2) наименование (*)
    protected boolean   isusr;  //5) используется в текущем проекте
    protected boolean   solvd;  //6) разрешено использование

class EiAuthor extends PrimitivElement {
    public static final int sizeAr=4;//количество полей в текстовом файле данных
    // TYP       keyEl;  //1) (ключ) значение в справочнике
    // TYP       keyBl;  //2) принадлежность
    // String    alias;  //3) читаемый элемент из не нормируемого источника(Ключ МАР)
    // long      status; //4) состояние элемента

-------------------------------------------------------------------------------------
abstract class BaseElement {//Guid=справочник,руководство
    private static int count=0;//cчетчик для элементов по умолчанию
    protected int       chang;  //1) время последней регистрации (* int)
    protected String    titul;  //2) наименование (*)
    protected String    descr;  //3) описание (*)
    protected int       typ;    //4) источник получения элемента (* short)
    protected boolean   isusr;  //5) используется в текущем проекте
    protected boolean   solvd;  //6) разрешено использование
    protected int       owner;  //7) идентификатор пользователя создавшего элемент
    protected int       key;    //8) время создания в секундах с 1 января 1970г.(ключ)

class EiPath extends BaseElement {
    public static final int sizeAr=8;//количество полей в текстовом файле данных
-----------------------------------------------------------------------------------
class ElmGr implements ElmPb {
//    private static final int mtst=-1;//максимальное смещение относительный уровень группировки
    private String  idr;    //01 идентификатор группировки
    private String  name;   //03 описание группировки из справоочника
    private String  pipl;   //08 формула суммирования
//    private int     izm;    //17 номер изменения раб.док = тип группировки
    private int     nur;    //19 номер записи
    private int     tst;    //величина отступа = относительный уровень группировки
    private int     grp;    //количество суммируемых элементов в данной строке

class ElmTs implements ElmPb {
    private String  idr;    //01 идентификатор работы
    private String  idb;    //02 идентификатор базовой работы
    private String  name;   //03 наименование работы
    private String  rd;     //04 номер раб.док
    private String  smin;   //05 инвентарный номер сметы
    private String  smln;   //06 локальный номер сметы
    private String  edi;    //07 единица измерния
    private String  pipl;   //08 исполнитель
    private double  lhor;   //09 сметые трудозатраты
    private double  ksm;    //10 общее количество
    private double  kost;   //11 остаток на начало ------------
    private double  kpl;    //12 план на период  --------------
    private double  csm;    //13 общая стоимость
    private double  cst;    //14 остаток на начало
    private double  cpl;    //15 пллан стоимости на период
    private double  cpt;    //16 пллан стоимости на период в текущих
    private int     izm;    //17 номер изменения раб.док
    private int     dtiz;   //18 дата изменения раб.док
    private int     nur;    //19 номер записи
    private int     dtbg;   //20 дата начала работы
    private int     dten;   //21 дата окончания работы
    private short   stat;   //22 статус работы 1-не начата,2-выполняется,3-завершена
    private int     tst;    //величина отступа
//    private int     grp;    //количество суммируемых элементов в данной строке

interface ElmPb {
    Object  getVal(int i);  //возврат значения по номеру поля с различными типами
    void    clear();        //очиистка
    void    setNur(int i);  //установка номер записи
    void    setform(StringBuilder sbl, int grp);
    void    setTst(int b);
//    int     getGrp();       //количество суммируемых элементов в данной строке
    int     getNur();       //номер записи
    String  getIdr();       //идентификатор группировки
    String  getName();      //описание группировки из справоочника
    String prn();
    //методы по умолчанию
    default int     getTst(){ return 0;} //величина отступа = относительный уровень группировки
    default String  getForm() { return null; }
    default String  getRd()   { return null; }
    default String  getSmin() { return null; }
    default String  getSmln() { return null; }
    default String  getPipl() { return null; }
    default double  getKsm() { return 0; }
    default double  getCsm() { return 0; }
    default double  getCst() { return 0; }
    default double  getCpl() { return 0; }
    default double  getCpt() { return 0; }
    default void    setKpl(double i){}
    default void    setKost(double i){}
}//ElmPb
------------------------------------------------------------------------------------
Все элементы могут быть трех видов:
1. линейный справочние lin: сортиовка
2. древовидный справочние tre: имя верхнего элемента и сортировка
3. матричный элемент из множества деревьев mtr: индивидуальный ключ для привязок
Матричный элемент предполагает таблицу отношений ко множесту деревьев и списков
Матричный элемент может быть сам группирующим уровнем, распадающимся на составляющиеся
части по одному или нескольким спискам или деревьям, тогда в нем появляется ссылка на
родителя. Если родитель исчезает, то ссылка переходит на прородителя.
Назначение справочника на матрицу может быть как моно, так и мульти
4. элемент связи между справочником и матричным элементом
5. элемент связи между матричными элементами может быть как функциональный так и
не функциональный (например показ приоритетов)

4,5:
public abstract class Destination
    protected   int       preds;  //1) предшествующий элемент (справочник)
    protected   int       suppr;  //2) последующий элемент матрица
    protected   int       owner;  //3) создатель элемента
    protected   int       creat;  //4) создание элемента
    protected   int       typep;  //5) тип предшественника элемент
    protected   long      stat;   //6) состояние элемента
    //(1-матрица не функционал, 2-матрица функционал, 3,4,...-справочники
    //0-метка конца 1-файлы 2-пути 3-пользователи
1:
public abstract class LineGuide  implements InfcElm
    protected   int       hasp;  //1)ключ, идентификатор элемента
    protected   String    title; //2)наименование элемента
    protected   String    descr; //3)описание элемента
    protected   long      stat;  //4) состояние элемента
    protected   int       order; //5)порядок следования

2(1):
public abstract class TreeGuide extends LineGuide
    protected   int       ances; //6)предок
    protected   int       nestd; //*)вложенность(начиная с 0, -1-нижний уровень) ????
3(2)
public abstract class MatrGuide extends TreeGuide
    protected   int       owner; //7) создатель элемента
    protected   int       creat; //8) создание элемента
    protected   int       chang; //9) время последней регистрации (* int)

+*--class EjAuthor extends LineGuide implements InfcElm//пример линейного
 !
 !  *--class AltTitle implements InfcElm
 !  !    String    title;  //наименование элемента
 !  !    String    alias;  //альтернативное название
 V  V
public interface InfcElm

public abstract class Ticked extends LineGuide implements ListElm, InfcElm
    protected   int     ancei;  //6 )КЛЮЧ предок
    protected   int     level;  //7 )уровень вложенности
    protected   int     owner;  //8 )идентификатор создателя записи
    protected   int     chang;  //9 )время редактирования записи в секундах с 1 января 1970г.
    protected   int     itypf;  //10)
    protected   int     ityps;  //11)
    protected   int     itypt;  //12)
    protected   String  link;   //13)ссылка на содержание
    protected   String  notes;  //14)примечание


*************************************************************************************
Новый вариант таблицы с учетом того что элементы могли быть созданы во время
автономной работы и при подключении к внешней базе требуется синхронизация
Пусть количество баз синхронизации ограничено числом Long 64/4=16 или 32/4=8
тогда значение 0 в тетраде означает что данная база еще не прочитана,
а 15 что данную базу не сканируем. Тогда таблица может выглядеть следующим образом
ввожу режим модификации, режим захвата поля для модификации
Если элемент не используется во внешней базе то и ни как не отрабатывается

бит С - синхронизован/локальный (изменения элемента не переданы внешним справочникам)
бит Р - разрешен/запрещено применение в дальнейшем
бит Л - создан локально/получен из внешних справочников
бит И - используется в локальном проекте/нет
бит Б - блокирован для локальной работы (изменения)
бит В - блокирован во внешнем справочнике (интеграционный от Б)

Пока элемент локальный колючом проверки является title, когда синхнонизуется то hasp
Флаг синхнонизации выставляется когда найден во ВСЕХ внешних базах и сверен ключ

Что интересно о внешнем элементе

1  бит Р - 1-разрешен/блокирован (увидел блокировку или выставил в зависимости от Л)
2  бит A - 1-актуальный/устарел    (зависит от Л )
4  бит С - 1-синхронизован/автономный   (зависит от Л )
8  бит Л - 1-получен из внешних справочников/создан локально
16 бит И - 1-используется в локальном проекте/нет    applied
Болкировка возможна только для актуальный элементов !!!
Асинхронный не может быть блокирован !!!

ИЛСAР       локальная интерпретация внешний элемент
-----+--+--+------------------------------------------+------------------------------
00000 00 F  локальный асинхронный устарел блокирован               ИСХОДНОЕ СОСТОЯНИЕ
00001 01    локальный асинхронный устарел разрешен                НАЛОЖЕНИЕ КЛЮЧЕЙ
00010 02  Z локальный асинхронный актуальный болкирован          РУЧНОЙ ВВОД
00011 03    локальный асинхронный актуальный разрешен            НОРМА
00100 04  X локальный синхронизован устарел болкирован           ИЗ ПО УМОЛЧАНИЮ > 03
00101 05    локальный синхронизован устарел разрешен             ПРЕДТЕЧЕ УДАЛЕНИЯ
00110 06    локальный синхронизован актуальный болкирован        ЗАХВАТ ДЛЯ ИЗМЕНЕНИЯ
00111 07    локальный синхронизован актуальный разрешен          НОРМА
-----+--+--+------------------------------------------+------------------------------
01000 08  X внешний асинхронный устарел болкирован               запрещен
01001 09    внешний асинхронный устарел разрешен         когда поработал автономно
01010 10    внешний асинхронный актуальный болкирован    когда поработал автономно
01011 11    внешний асинхронный актуальный разрешен      когда поработал автономно
01100 12  V внешний синхронизован устарел болкирован
01101 13    внешний синхронизован устарел разрешен
01110 14    внешний синхронизован актуальный болкирован
01111 15    внешний синхронизован актуальный разрешен
-----+--+--+------------------------------------------+------------------------------
10000 16 R  исп-ся локальный асинхронный устарел блокирован     НЕ ПРОВЕРЯТЬ
10001 17    исп-ся локальный асинхронный устарел разрешен       КОСВЕННОЕ СОЗДАНИЕ
10010 18  X исп-ся локальный асинхронный актуальный болкирован  РУЧНОЙ ВВОД
10011 19    исп-ся локальный асинхронный актуальный разрешен
10100 20  X исп-ся локальный синхронизован устарел болкирован   ИЗ ДОКУМЕНТОВ >03
10101 21    исп-ся
10110 22    исп-ся
10111 23    исп-ся
-----+--+--+------------------------------------------+------------+-----------------
11000 24 X  исп-ся внешний асинхронный устарел болкирован    запрещен
11001 25    исп-ся внешний асинхронный устарел разрешен      когда поработал автономно
11010 26    исп-ся внешний асинхронный актуальный болкирован когда поработал автономно
11011 26    исп-ся внешний асинхронный актуальный разрешен   когда поработал автономно
11100 28  V исп-ся внешний синхронизован устарел болкирован
11101 29    исп-ся внешний синхронизован устарел разрешен
11110 30    исп-ся внешний синхронизован актуальный болкирован
11111 31    исп-ся внешний синхронизован актуальный разрешен
-----+--+--+------------------------------------------+------------------------------

Приобработке статуса могут быть инициированы следующие поведения системы  behaviour
0 - идем дальше по колекции
1 - все сделано внутри метода. выходим из цикла
2 - выходим из цикла. добавляем элемента
3 - выходим из цикла. удалениу элемента из локальной коллекции

Типы используемых массивов ***********************************************************
public static ArrayList<ListElm>    lst =new ArrayList<>(2)--для сортировки элементов
public static Map<String, InfcElm>  mar =new HashMap<>(2)--для первоначальной подкачки
public static Map<Integer, InfcElm> ary =new HashMap<>(12)--для хранения данных

public static Map<String, ListElm> lsts =new HashMap<>(12)--ссылки по title на lst
public static Map<Integer,ListElm> lsti =new HashMap<>(12)--ссылки по hasp  на lst

Процедура слияния данных ************************************************************
*) hasp является функцией от  title следовательно ключевая проверка идет по title
*) hasp используется для перекрестных ссылок между записями для скорости

1) Проверяю совпаадение hasp. Если совпал, то проверяю title
 hasp=Д title=Д ) правильный элемент, корректирую поля в зависимости от происхождения
 объекты идентичны если все поля кроме way совпадают. Тогда анализируем только way.
 Если поля не совпали, тогда бействуем на основании данных way.
 hasp=Д title=Н ) наложение ключей для разных элементов. Если элемент создан здесь и
 не синхронизован в сети тогда изменяю его ключ с корректировкой связей иначе игнорирую
 hasp=Н title=Д ) один элемент имеет несколько ключей. Избавляюсь от дублирования.
 Проверяю на синхронизацию. Если синхронизован значит уже заявлен в сети, если нет то
 вновь созданный элемен. Если один синхнонизован, а другой автономный, то выбираю
 синхнонизованыый, иначе делаю следующую проверку.
 Проверяю актуальность элементов.
 Если один актуальный а другой нет, тогда выбираю актуальный, иначе следующая проверка
 Проверяю элементы на использование.
 Если один используется, а другой нет то выбираю использующийся с принятием его полей
 Если они оба используются или не используются тогда выбираю с меньшим hasp.
 hasp=Н title=Н ) это новый элемен. Добавляю элемент в коллекцию

 Что интересно о внешнем элементе



 1  бит Р - 1-разрешен/блокирован (увидел блокировку или выставил в зависимости от Л)
 2  бит A - 1-актуальный/устарел    (зависит от Л )
 4  бит С - 1-синхронизован/автономный   (зависит от Л )
 8  бит Л - 1-получен из внешних справочников/создан локально
 16 бит И - 1-используется в локальном проекте/нет    applied
 Болкировка возможна только для актуальный элементов !!!
 Асинхронный не может быть блокирован !!!

 ИСAР       локальная интерпретация внешний элемент
 ----+--+--+---------------------+-----------------------------------------+---------
 0000 00        асинхр удален     пометил на удаление     жду синхронизации  не прочитана
 0001 01        асинхр изменен    после редактирования    жду синхронизации
 0010 02        асинхр базовый    получен ИЗ ДОКУМЕНТОВ   жду синхронизации
 0011 03        асинхр актуальный РУЧНОЙ ВВОД             жду синхронизации
 0100 04  X     синхр  удален     ПО УМОЛЧАНИЮ            неизменяем
 0101 05        синхр  изменен    готов к удалению, жду команды на удаление
 0110 06        синхр  базовый    НОРМА получен из документов или ручной
 0111 07        синхр  актуальный НОРМА из внешних источников или изменения
 ----+--+--+---------------------+-----------------------------------------+---------
 1000 08    исп асинхр удален     пометил на удаление     жду ЗАМЕЩЕНИЯ      не читать
 1001 09    исп асинхр изменен    после редактирования    жду ЗАМЕЩЕНИя
 1010 10    исп асинхр базовый    НОРМА, КОСВЕННОЕ СОЗДАНИЕ
 1011 11    исп асинхр актуальный НОРМА                   жду синхронизации
 1100 12    исп синхр  удален     ЗАМЕЩЕНИЕ           жду внешних замещений
 1101 13    исп синхр  изменен    ЗАМЕЩЕНИЕ           жду внешних замещений
 1110 14    исп синхр  базовый    НОРМА
 1111 15    исп синхр  актуальный НОРМА
 ----+--+--+---------------------+-----------------------------------------+---------

Новый вариант таблицы с учетом того что элементы могли быть созданы во время
автономной работы и при подключении к внешней базе требуется синхронизация
Пусть количество баз синхронизации ограничено числом Long 64/4=16 или 32/4=8
тогда значение 0 в тетраде означает что данная база еще не прочитана,
а 15 что данную базу не сканируем. Тогда таблица может выглядеть следующим образом
ввожу режим модификации, режим захвата поля для модификации
Если элемент не используется во внешней базе то и ни как не отрабатывается
 ИСAР       локальная интерпретация внешний элемент
 ----+--+--+---------------------+-----------------------------------------+---------
 0000 00  X                                        внешние данные еще не прочитаны
 0001 01        асинхр удален     пометил на удаление    жду синхронизации
 0010 02        асинхр изменен    после редактирования   жду синхронизации
 0011 03        асинхр актуальный РУЧНОЙ ВВОД,ИЗ ДОКУМЕНТОВ жду синхронизации
 0100 04  X     ПО УМОЛЧАНИЮ
 0101 05        синхр  удален
 0110 06        синхр  изменен    готов к удалению, жду команды на удаление
 0111 07        синхр  актуальный НОРМА из внешних источников или изменения
 ----+--+--+---------------------+-----------------------------------------+---------
 1000 08  X КОСВЕННОЕ СОЗДАНИЕ
 1001 09    исп асинхр удален     после редактирования    жду ЗАМЕЩЕНИя
 1010 10    исп асинхр изменен    пометил на удаление     жду ЗАМЕЩЕНИЯ
 1011 11    исп асинхр актуальный НОРМА                   жду синхронизации
 1100 12  X                                         внешний элемент не обрабатывать
 1101 13    исп синхр  удален     ЗАМЕЩЕНИЕ           жду внешних замещений
 1110 14    исп синхр  изменен    ЗАМЕЩЕНИЕ           жду внешних замещений
 1111 15    исп синхр  актуальный НОРМА
 ----+--+--+---------------------+-----------------------------------------+---------

 1  бит Р - 1-разрешен/блокирован (увидел блокировку или выставил в зависимости от Л)
 2  бит A - 1-актуальный/устарел    (зависит от Л )
 4  бит И - 1-используется в локальном проекте/нет    applied
 8  бит С - 1-синхронизован/автономный   (зависит от Л )
 СИAР       локальная интерпретация внешний элемент
 ----+--+--+---------------------+-----------------------------------------+---------
 0000 00  X                                        внешние данные еще не прочитаны
 0001 01        асинхр удален     пометил на удаление    жду синхронизации
 0010 02        асинхр изменен    после редактирования   жду синхронизации
 0011 03        асинхр актуальный РУЧНОЙ ВВОД,ИЗ ДОКУМЕНТОВ жду синхронизации
 0100 04  X КОСВЕННОЕ СОЗДАНИЕ
 0101 05    исп асинхр удален     после редактирования    жду ЗАМЕЩЕНИя
 0110 06    исп асинхр изменен    пометил на удаление     жду ЗАМЕЩЕНИЯ
 0111 07    исп асинхр актуальный НОРМА                   жду синхронизации
 ----+--+--+---------------------+-----------------------------------------+---------
 1000 08  X     ПО УМОЛЧАНИЮ
 1001 09        синхр  удален
 1010 10        синхр  изменен    готов к удалению, жду команды на удаление
 1011 11        синхр  актуальный НОРМА из внешних источников или изменения
 1100 12  X                                         внешний элемент не обрабатывать
 1101 13    исп синхр  удален     ЗАМЕЩЕНИЕ           жду внешних замещений
 1110 14    исп синхр  изменен    ЗАМЕЩЕНИЕ           жду внешних замещений
 1111 15    исп синхр  актуальный НОРМА
 ----+--+--+---------------------+-----------------------------------------+---------









q